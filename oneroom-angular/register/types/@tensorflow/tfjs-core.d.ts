export class AdadeltaOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any, rho: any, epsilon: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
}
export class AdagradOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any, initialAccumulatorValue: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
}
export class AdamOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any, beta1: any, beta2: any, epsilon: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
}
export class AdamaxOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any, beta1: any, beta2: any, epsilon: any, decay: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
}
export class DataStorage {
  constructor(dataMover: any);
  dataMover: any;
  data: any;
  get(dataId: any): any;
  has(dataId: any): any;
  set(dataId: any, value: any): void;
}
export const ENV: {
  backend: any;
  engine: any;
  evaluateFeature: Function;
  features: {
    DEBUG: boolean;
    IS_BROWSER: boolean;
  };
  findBackend: Function;
  get: Function;
  getBestBackendName: Function;
  getFeatures: Function;
  initEngine: Function;
  registerBackend: Function;
  registry: {
    cpu: {
      backend: {
        LRNGrad: any;
        abs: any;
        acos: any;
        acosh: any;
        add: any;
        addN: any;
        all: any;
        any: any;
        argMax: any;
        argMin: any;
        asin: any;
        asinh: any;
        assertNotComplex: any;
        atan: any;
        atan2: any;
        atanh: any;
        avgPool: any;
        avgPoolBackprop: any;
        batchMatMul: any;
        batchNormalization: any;
        batchToSpaceND: any;
        blockSize: any;
        broadcastedBinaryComplexOp: any;
        broadcastedBinaryOp: any;
        cast: any;
        ceil: any;
        clip: any;
        complex: any;
        complexAbs: any;
        concat: any;
        conv2d: any;
        conv2dDerFilter: any;
        conv2dDerInput: any;
        conv3d: any;
        conv3dDerFilter: any;
        conv3dDerInput: any;
        cos: any;
        cosh: any;
        cropAndResize: any;
        cumsum: any;
        data: any;
        depthToSpace: any;
        depthwiseConv2D: any;
        depthwiseConv2DDerFilter: any;
        depthwiseConv2DDerInput: any;
        dispose: any;
        disposeData: any;
        elu: any;
        eluDer: any;
        equal: any;
        erf: any;
        exp: any;
        expm1: any;
        fft: any;
        fftBatch: any;
        fftImpl: any;
        fftRadix2: any;
        firstUse: any;
        floatPrecision: any;
        floor: any;
        floorDiv: any;
        fourierTransformByMatmul: any;
        fromPixels: any;
        fusedBatchMatMul: any;
        gather: any;
        gatherND: any;
        greater: any;
        greaterEqual: any;
        ifft: any;
        imag: any;
        int: any;
        isExponentOf2: any;
        less: any;
        lessEqual: any;
        linear: any;
        localResponseNormalization4D: any;
        log: any;
        log1p: any;
        logicalAnd: any;
        logicalNot: any;
        logicalOr: any;
        max: any;
        maxPool: any;
        maxPoolBackprop: any;
        maxPoolPositions: any;
        maximum: any;
        memory: any;
        min: any;
        minimum: any;
        mod: any;
        multinomial: any;
        multiply: any;
        neg: any;
        nonMaxSuppression: any;
        notEqual: any;
        oneHot: any;
        pad: any;
        pool: any;
        pow: any;
        prelu: any;
        prod: any;
        read: any;
        readSync: any;
        real: any;
        realDivide: any;
        reciprocal: any;
        register: any;
        relu: any;
        reshape: any;
        resizeBilinear: any;
        resizeBilinearBackprop: any;
        resizeNearestNeighbor: any;
        resizeNearestNeighborBackprop: any;
        reverse: any;
        round: any;
        rsqrt: any;
        scatter: any;
        scatterND: any;
        select: any;
        selu: any;
        setDataMover: any;
        sigmoid: any;
        sign: any;
        sin: any;
        sinh: any;
        slice: any;
        softplus: any;
        spaceToBatchND: any;
        sparseToDense: any;
        split: any;
        sqrt: any;
        square: any;
        squaredDifference: any;
        step: any;
        stridedSlice: any;
        subtract: any;
        sum: any;
        tan: any;
        tanh: any;
        tile: any;
        time: any;
        topk: any;
        transpose: any;
        unsortedSegmentSum: any;
        unstack: any;
        where: any;
        write: any;
      };
      priority: number;
    };
  };
  removeBackend: Function;
  reset: Function;
  set: Function;
  setFeatures: Function;
};
export class Environment {
  static dispose(container: any): void;
  static disposeVariables(): void;
  static getBackend(): any;
  static keep(result: any): any;
  static memory(): any;
  static profile(f: any): any;
  static setBackend(backendName: any, safeMode: any): void;
  static tidy(nameOrFn: any, fn: any): any;
  static time(f: any): any;
  constructor(features: any);
  features: any;
  registry: any;
  evaluateFeature(feature: any): any;
  findBackend(name: any): any;
  get(feature: any): any;
  getBestBackendName(): any;
  getFeatures(): any;
  initEngine(): void;
  registerBackend(name: any, factory: any, priority: any, setTensorTrackerFn: any): any;
  removeBackend(name: any): void;
  reset(): void;
  set(feature: any, value: any): void;
  setFeatures(features: any): void;
}
export class KernelBackend {
  LRNGrad(dy: any, inputImage: any, outputImage: any, radius: any, bias: any, alpha: any, beta: any): void;
  abs(x: any): void;
  acos(x: any): void;
  acosh(x: any): void;
  add(a: any, b: any): void;
  addN(tensors: any): void;
  all(x: any, axes: any): void;
  any(x: any, axes: any): void;
  argMax(x: any, axis: any): void;
  argMin(x: any, axis: any): void;
  asin(x: any): void;
  asinh(x: any): void;
  atan(x: any): void;
  atan2(a: any, b: any): void;
  atanh(x: any): void;
  avgPool(x: any, convInfo: any): void;
  avgPoolBackprop(dy: any, x: any, convInfo: any): void;
  batchMatMul(a: any, b: any, transposeA: any, transposeB: any): void;
  batchNormalization(x: any, mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): void;
  batchToSpaceND(x: any, blockShape: any, crops: any): void;
  cast(x: any, dtype: any): void;
  ceil(x: any): void;
  clip(x: any, min: any, max: any): void;
  complex(real: any, imag: any): void;
  complexAbs(x: any): void;
  concat(tensors: any, axis: any): void;
  conv2d(x: any, filter: any, convInfo: any): void;
  conv2dDerFilter(x: any, dY: any, convInfo: any): void;
  conv2dDerInput(dy: any, filter: any, convInfo: any): void;
  conv3d(x: any, filter: any, convInfo: any): void;
  conv3dDerFilter(x: any, dY: any, convInfo: any): void;
  conv3dDerInput(dy: any, filter: any, convInfo: any): void;
  cos(x: any): void;
  cosh(x: any): void;
  cropAndResize(image: any, boxes: any, boxIndex: any, cropSize: any, method: any, extrapolationValue: any): void;
  cumsum(x: any, axis: any, exclusive: any, reverse: any): void;
  depthToSpace(x: any, blockSize: any, dataFormat: any): void;
  depthwiseConv2D(input: any, filter: any, convInfo: any): void;
  depthwiseConv2DDerFilter(x: any, dY: any, convInfo: any): void;
  depthwiseConv2DDerInput(dy: any, filter: any, convInfo: any): void;
  dispose(): void;
  disposeData(dataId: any): void;
  elu(x: any): void;
  eluDer(dy: any, y: any): void;
  equal(a: any, b: any): void;
  erf(x: any): void;
  exp(x: any): void;
  expm1(x: any): void;
  fft(x: any): void;
  floatPrecision(): void;
  floor(x: any): void;
  floorDiv(a: any, b: any): void;
  fromPixels(pixels: any, numChannels: any): void;
  fusedBatchMatMul(a: any, b: any, transposeA: any, transposeB: any, bias: any, activation: any): void;
  gather(x: any, indices: any, axis: any): void;
  gatherND(x: any, indices: any): void;
  greater(a: any, b: any): void;
  greaterEqual(a: any, b: any): void;
  ifft(x: any): void;
  imag(input: any): void;
  int(x: any): void;
  less(a: any, b: any): void;
  lessEqual(a: any, b: any): void;
  localResponseNormalization4D(x: any, radius: any, bias: any, alpha: any, beta: any): void;
  log(x: any): void;
  log1p(x: any): void;
  logicalAnd(a: any, b: any): void;
  logicalNot(a: any): void;
  logicalOr(a: any, b: any): void;
  max(x: any, axes: any): void;
  maxPool(x: any, convInfo: any): void;
  maxPoolBackprop(dy: any, x: any, y: any, convInfo: any): void;
  maximum(a: any, b: any): void;
  memory(): void;
  min(x: any, axes: any): void;
  minimum(a: any, b: any): void;
  mod(a: any, b: any): void;
  multinomial(logits: any, normalized: any, numSamples: any, seed: any): void;
  multiply(a: any, b: any): void;
  neg(a: any): void;
  nonMaxSuppression(boxes: any, scores: any, maxOutputSize: any, iouThreshold: any, scoreThreshold: any): void;
  notEqual(a: any, b: any): void;
  oneHot(indices: any, depth: any, onValue: any, offValue: any): void;
  pad(x: any, paddings: any, constantValue: any): void;
  pow(a: any, b: any): void;
  prelu(x: any, a: any): void;
  prod(x: any, axes: any): void;
  read(dataId: any): void;
  readSync(dataId: any): void;
  real(input: any): void;
  realDivide(a: any, b: any): void;
  reciprocal(x: any): void;
  register(dataId: any, shape: any, dtype: any): void;
  relu(x: any): void;
  reshape(x: any, shape: any): void;
  resizeBilinear(x: any, newHeight: any, newWidth: any, alignCorners: any): void;
  resizeBilinearBackprop(dy: any, x: any, alignCorners: any): void;
  resizeNearestNeighbor(x: any, newHEight: any, newWidth: any, alignCorners: any): void;
  resizeNearestNeighborBackprop(dy: any, x: any, alignCorners: any): void;
  reverse(a: any, axis: any): void;
  round(x: any): void;
  rsqrt(x: any): void;
  scatterND(indices: any, updates: any, shape: any): void;
  select(condition: any, a: any, b: any): void;
  selu(x: any): void;
  setDataMover(dataMover: any): void;
  sigmoid(x: any): void;
  sign(x: any): void;
  sin(x: any): void;
  sinh(x: any): void;
  slice(x: any, begin: any, size: any): void;
  softplus(x: any): void;
  spaceToBatchND(x: any, blockShape: any, paddings: any): void;
  sparseToDense(sparseIndices: any, sparseValues: any, outputShape: any, defaultValue: any): void;
  split(value: any, sizeSplits: any, axis: any): void;
  sqrt(x: any): void;
  square(x: any): void;
  squaredDifference(a: any, b: any): void;
  step(x: any, alpha: any): void;
  stridedSlice(x: any, begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): void;
  subtract(a: any, b: any): void;
  sum(x: any, axes: any): void;
  tan(x: any): void;
  tanh(x: any): void;
  tile(x: any, reps: any): void;
  time(f: any): void;
  topk(x: any, k: any, sorted: any): void;
  transpose(x: any, perm: any): void;
  unsortedSegmentSum(x: any, segmentIds: any, numSegments: any): void;
  unstack(x: any, axis: any): void;
  where(condition: any): void;
  write(dataId: any, values: any): void;
}
export class MomentumOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any, momentum: any, useNesterov: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
  setLearningRate(learningRate: any): void;
  setMomentum(momentum: any): void;
}
export class Optimizer {
  static fromConfig(cls: any, config: any): any;
  constructor(...args: any[]);
  computeGradients(f: any, varList: any): any;
  getClassName(): any;
  minimize(f: any, returnCost: any, varList: any): any;
}
export class RMSPropOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any, decay: any, momentum: any, epsilon: any, centered: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
}
export const Rank: {
  R0: string;
  R1: string;
  R2: string;
  R3: string;
  R4: string;
  R5: string;
  R6: string;
};
export const Reduction: {
  "0": string;
  "1": string;
  "2": string;
  "3": string;
  MEAN: number;
  NONE: number;
  SUM: number;
  SUM_BY_NONZERO_WEIGHTS: number;
};
export class SGDOptimizer {
  static className: string;
  static fromConfig(cls: any, config: any): any;
  constructor(learningRate: any);
  applyGradients(variableGradients: any): void;
  computeGradients(f: any, varList: any): any;
  dispose(): void;
  getClassName(): any;
  getConfig(): any;
  minimize(f: any, returnCost: any, varList: any): any;
  setLearningRate(learningRate: any): void;
}
export class Tensor {
  static make(shape: any, data: any, dtype: any): any;
  constructor(shape: any, dtype: any, values: any, dataId: any);
  isDisposedInternal: any;
  shape: any;
  dtype: any;
  size: any;
  strides: any;
  dataId: any;
  id: any;
  rankType: any;
  abs(): any;
  acos(): any;
  acosh(): any;
  add(x: any): any;
  addStrict(x: any): any;
  all(axis: any, keepDims: any): any;
  any(axis: any, keepDims: any): any;
  argMax(axis: any): any;
  argMin(axis: any): any;
  array(): any;
  arraySync(): any;
  as1D(): any;
  as2D(rows: any, columns: any): any;
  as3D(rows: any, columns: any, depth: any): any;
  as4D(rows: any, columns: any, depth: any, depth2: any): any;
  as5D(rows: any, columns: any, depth: any, depth2: any, depth3: any): any;
  asScalar(): any;
  asType(dtype: any): any;
  asin(): any;
  asinh(): any;
  atan(): any;
  atan2(x: any): any;
  atanh(): any;
  avgPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
  batchNorm(mean: any, variance: any, offset: any, scale: any, varianceEpsilon: any): any;
  batchNormalization(mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): any;
  batchToSpaceND(blockShape: any, crops: any): any;
  buffer(): any;
  bufferSync(): any;
  cast(dtype: any): any;
  ceil(): any;
  clipByValue(min: any, max: any): any;
  clone(): any;
  concat(x: any, axis: any): any;
  conv1d(filter: any, stride: any, pad: any, dataFormat: any, dilation: any, dimRoundingMode: any): any;
  conv2d(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
  conv2dTranspose(filter: any, outputShape: any, strides: any, pad: any, dimRoundingMode: any): any;
  cos(): any;
  cosh(): any;
  cumsum(axis: any, exclusive: any, reverse: any): any;
  data(): any;
  dataSync(): any;
  depthToSpace(blockSize: any, dataFormat: any): any;
  depthwiseConv2D(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
  dispose(): void;
  div(x: any): any;
  divStrict(x: any): any;
  dot(b: any): any;
  elu(): any;
  equal(x: any): any;
  equalStrict(x: any): any;
  erf(): any;
  exp(): any;
  expandDims(axis: any): any;
  expm1(): any;
  fft(): any;
  flatten(): any;
  floor(): any;
  floorDiv(x: any): any;
  gather(indices: any, axis: any): any;
  get(...args: any[]): any;
  greater(x: any): any;
  greaterEqual(x: any): any;
  greaterEqualStrict(x: any): any;
  greaterStrict(x: any): any;
  ifft(): any;
  irfft(): any;
  leakyRelu(alpha: any): any;
  less(x: any): any;
  lessEqual(x: any): any;
  lessEqualStrict(x: any): any;
  lessStrict(x: any): any;
  localResponseNormalization(radius: any, bias: any, alpha: any, beta: any): any;
  log(): any;
  log1p(): any;
  logSigmoid(): any;
  logSoftmax(axis: any): any;
  logSumExp(axis: any, keepDims: any): any;
  logicalAnd(x: any): any;
  logicalNot(): any;
  logicalOr(x: any): any;
  logicalXor(x: any): any;
  matMul(b: any, transposeA: any, transposeB: any): any;
  max(axis: any, keepDims: any): any;
  maxPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
  maximum(x: any): any;
  maximumStrict(x: any): any;
  mean(axis: any, keepDims: any): any;
  min(axis: any, keepDims: any): any;
  minimum(x: any): any;
  minimumStrict(x: any): any;
  mod(x: any): any;
  modStrict(x: any): any;
  mul(x: any): any;
  mulStrict(x: any): any;
  neg(): any;
  norm(ord: any, axis: any, keepDims: any): any;
  notEqual(x: any): any;
  notEqualStrict(x: any): any;
  oneHot(depth: any, onValue: any, offValue: any): any;
  onesLike(): any;
  pad(paddings: any, constantValue: any): any;
  pool(windowShape: any, poolingType: any, padding: any, dilationRate: any, strides: any): any;
  pow(exp: any): any;
  powStrict(exp: any): any;
  prelu(alpha: any): any;
  print(verbose: any): any;
  prod(axis: any, keepDims: any): any;
  reciprocal(): any;
  relu(): any;
  reshape(newShape: any): any;
  reshapeAs(x: any): any;
  resizeBilinear(newShape2D: any, alignCorners: any): any;
  resizeNearestNeighbor(newShape2D: any, alignCorners: any): any;
  reverse(axis: any): any;
  rfft(): any;
  round(): any;
  rsqrt(): any;
  selu(): any;
  separableConv2d(depthwiseFilter: any, pointwiseFilter: any, strides: any, pad: any, dilation: any, dataFormat: any): any;
  sigmoid(): any;
  sign(): any;
  sin(): any;
  sinh(): any;
  slice(begin: any, size: any): any;
  softmax(dim: any): any;
  softplus(): any;
  spaceToBatchND(blockShape: any, paddings: any): any;
  split(numOrSizeSplits: any, axis: any): any;
  sqrt(): any;
  square(): any;
  squaredDifference(x: any): any;
  squaredDifferenceStrict(x: any): any;
  squeeze(axis: any): any;
  stack(x: any, axis: any): any;
  step(alpha: any): any;
  stridedSlice(begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): any;
  sub(x: any): any;
  subStrict(x: any): any;
  sum(axis: any, keepDims: any): any;
  tan(): any;
  tanh(): any;
  throwIfDisposed(): void;
  tile(reps: any): any;
  toBool(): any;
  toFloat(): any;
  toInt(): any;
  toString(verbose: any): any;
  topk(k: any, sorted: any): any;
  transpose(perm: any): any;
  unsortedSegmentSum(segmentIds: any, numSegments: any): any;
  unstack(x: any, axis: any): any;
  variable(trainable: any, name: any, dtype: any): any;
  where(condition: any, x: any): any;
  zerosLike(): any;
}
export class TensorBuffer {
  constructor(shape: any, dtype: any, values: any);
  dtype: any;
  shape: any;
  size: any;
  values: any;
  strides: any;
  get(...args: any[]): any;
  indexToLoc(index: any): any;
  locToIndex(locs: any): any;
  set(value: any, ...args: any[]): void;
  toTensor(): any;
}
export class Variable {
  static make(shape: any, data: any, dtype: any): any;
  static variable(initialValue: any, trainable: any, name: any, dtype: any): any;
  constructor(initialValue: any, trainable: any, name: any);
  abs(): any;
  acos(): any;
  acosh(): any;
  add(x: any): any;
  addStrict(x: any): any;
  all(axis: any, keepDims: any): any;
  any(axis: any, keepDims: any): any;
  argMax(axis: any): any;
  argMin(axis: any): any;
  array(): any;
  arraySync(): any;
  as1D(): any;
  as2D(rows: any, columns: any): any;
  as3D(rows: any, columns: any, depth: any): any;
  as4D(rows: any, columns: any, depth: any, depth2: any): any;
  as5D(rows: any, columns: any, depth: any, depth2: any, depth3: any): any;
  asScalar(): any;
  asType(dtype: any): any;
  asin(): any;
  asinh(): any;
  assign(newValue: any): void;
  atan(): any;
  atan2(x: any): any;
  atanh(): any;
  avgPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
  batchNorm(mean: any, variance: any, offset: any, scale: any, varianceEpsilon: any): any;
  batchNormalization(mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): any;
  batchToSpaceND(blockShape: any, crops: any): any;
  buffer(): any;
  bufferSync(): any;
  cast(dtype: any): any;
  ceil(): any;
  clipByValue(min: any, max: any): any;
  clone(): any;
  concat(x: any, axis: any): any;
  conv1d(filter: any, stride: any, pad: any, dataFormat: any, dilation: any, dimRoundingMode: any): any;
  conv2d(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
  conv2dTranspose(filter: any, outputShape: any, strides: any, pad: any, dimRoundingMode: any): any;
  cos(): any;
  cosh(): any;
  cumsum(axis: any, exclusive: any, reverse: any): any;
  data(): any;
  dataSync(): any;
  depthToSpace(blockSize: any, dataFormat: any): any;
  depthwiseConv2D(filter: any, strides: any, pad: any, dataFormat: any, dilations: any, dimRoundingMode: any): any;
  dispose(): void;
  div(x: any): any;
  divStrict(x: any): any;
  dot(b: any): any;
  elu(): any;
  equal(x: any): any;
  equalStrict(x: any): any;
  erf(): any;
  exp(): any;
  expandDims(axis: any): any;
  expm1(): any;
  fft(): any;
  flatten(): any;
  floor(): any;
  floorDiv(x: any): any;
  gather(indices: any, axis: any): any;
  get(...args: any[]): any;
  greater(x: any): any;
  greaterEqual(x: any): any;
  greaterEqualStrict(x: any): any;
  greaterStrict(x: any): any;
  ifft(): any;
  irfft(): any;
  leakyRelu(alpha: any): any;
  less(x: any): any;
  lessEqual(x: any): any;
  lessEqualStrict(x: any): any;
  lessStrict(x: any): any;
  localResponseNormalization(radius: any, bias: any, alpha: any, beta: any): any;
  log(): any;
  log1p(): any;
  logSigmoid(): any;
  logSoftmax(axis: any): any;
  logSumExp(axis: any, keepDims: any): any;
  logicalAnd(x: any): any;
  logicalNot(): any;
  logicalOr(x: any): any;
  logicalXor(x: any): any;
  matMul(b: any, transposeA: any, transposeB: any): any;
  max(axis: any, keepDims: any): any;
  maxPool(filterSize: any, strides: any, pad: any, dimRoundingMode: any): any;
  maximum(x: any): any;
  maximumStrict(x: any): any;
  mean(axis: any, keepDims: any): any;
  min(axis: any, keepDims: any): any;
  minimum(x: any): any;
  minimumStrict(x: any): any;
  mod(x: any): any;
  modStrict(x: any): any;
  mul(x: any): any;
  mulStrict(x: any): any;
  neg(): any;
  norm(ord: any, axis: any, keepDims: any): any;
  notEqual(x: any): any;
  notEqualStrict(x: any): any;
  oneHot(depth: any, onValue: any, offValue: any): any;
  onesLike(): any;
  pad(paddings: any, constantValue: any): any;
  pool(windowShape: any, poolingType: any, padding: any, dilationRate: any, strides: any): any;
  pow(exp: any): any;
  powStrict(exp: any): any;
  prelu(alpha: any): any;
  print(verbose: any): any;
  prod(axis: any, keepDims: any): any;
  reciprocal(): any;
  relu(): any;
  reshape(newShape: any): any;
  reshapeAs(x: any): any;
  resizeBilinear(newShape2D: any, alignCorners: any): any;
  resizeNearestNeighbor(newShape2D: any, alignCorners: any): any;
  reverse(axis: any): any;
  rfft(): any;
  round(): any;
  rsqrt(): any;
  selu(): any;
  separableConv2d(depthwiseFilter: any, pointwiseFilter: any, strides: any, pad: any, dilation: any, dataFormat: any): any;
  sigmoid(): any;
  sign(): any;
  sin(): any;
  sinh(): any;
  slice(begin: any, size: any): any;
  softmax(dim: any): any;
  softplus(): any;
  spaceToBatchND(blockShape: any, paddings: any): any;
  split(numOrSizeSplits: any, axis: any): any;
  sqrt(): any;
  square(): any;
  squaredDifference(x: any): any;
  squaredDifferenceStrict(x: any): any;
  squeeze(axis: any): any;
  stack(x: any, axis: any): any;
  step(alpha: any): any;
  stridedSlice(begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): any;
  sub(x: any): any;
  subStrict(x: any): any;
  sum(axis: any, keepDims: any): any;
  tan(): any;
  tanh(): any;
  throwIfDisposed(): void;
  tile(reps: any): any;
  toBool(): any;
  toFloat(): any;
  toInt(): any;
  toString(verbose: any): any;
  topk(k: any, sorted: any): any;
  transpose(perm: any): any;
  unsortedSegmentSum(segmentIds: any, numSegments: any): any;
  unstack(x: any, axis: any): any;
  variable(trainable: any, name: any, dtype: any): any;
  where(condition: any, x: any): any;
  zerosLike(): any;
}
export function abs(...args: any[]): any;
export function acos(...args: any[]): any;
export function acosh(...args: any[]): any;
export function add(...args: any[]): any;
export function addN(...args: any[]): any;
export function addStrict(...args: any[]): any;
export function all(...args: any[]): any;
export function any(...args: any[]): any;
export function argMax(...args: any[]): any;
export function argMin(...args: any[]): any;
export function asin(...args: any[]): any;
export function asinh(...args: any[]): any;
export function atan(...args: any[]): any;
export function atan2(...args: any[]): any;
export function atanh(...args: any[]): any;
export function avgPool(...args: any[]): any;
export function basicLSTMCell(...args: any[]): any;
export function batchNorm(...args: any[]): any;
export function batchNorm2d(...args: any[]): any;
export function batchNorm3d(...args: any[]): any;
export function batchNorm4d(...args: any[]): any;
export function batchNormalization(...args: any[]): any;
export function batchNormalization2d(...args: any[]): any;
export function batchNormalization3d(...args: any[]): any;
export function batchNormalization4d(...args: any[]): any;
export function batchToSpaceND(...args: any[]): any;
export namespace browser {
  function fromPixels(...args: any[]): any;
  function toPixels(img: any, canvas: any): any;
}
export function buffer(shape: any, dtype: any, values: any): any;
export function cast(...args: any[]): any;
export function ceil(...args: any[]): any;
export function clipByValue(...args: any[]): any;
export function clone(...args: any[]): any;
export function complex(...args: any[]): any;
export function concat(...args: any[]): any;
export function concat1d(...args: any[]): any;
export function concat2d(...args: any[]): any;
export function concat3d(...args: any[]): any;
export function concat4d(...args: any[]): any;
export function conv1d(...args: any[]): any;
export function conv2d(...args: any[]): any;
export function conv2dDerFilter(...args: any[]): any;
export function conv2dTranspose(...args: any[]): any;
export function conv3d(...args: any[]): any;
export function cos(...args: any[]): any;
export function cosh(...args: any[]): any;
export function cumsum(...args: any[]): any;
export function customGrad(f: any): any;
export function deprecationWarn(msg: any): void;
export function depthToSpace(...args: any[]): any;
export function depthwiseConv2d(...args: any[]): any;
export function disableDeprecationWarnings(): void;
export function dispose(container: any): void;
export function disposeVariables(): void;
export function div(...args: any[]): any;
export function divStrict(...args: any[]): any;
export function dot(...args: any[]): any;
export function elu(...args: any[]): any;
export function enableProdMode(): void;
export namespace environment {
  const ENV: {
    backend: any;
    engine: any;
    evaluateFeature: Function;
    features: {
      DEBUG: boolean;
      IS_BROWSER: boolean;
    };
    findBackend: Function;
    get: Function;
    getBestBackendName: Function;
    getFeatures: Function;
    initEngine: Function;
    registerBackend: Function;
    registry: {
      cpu: {
        backend: any;
        priority: any;
      };
    };
    removeBackend: Function;
    reset: Function;
    set: Function;
    setFeatures: Function;
  };
  const EPSILON_FLOAT16: number;
  const EPSILON_FLOAT32: number;
  class Environment {
    static dispose(container: any): void;
    static disposeVariables(): void;
    static getBackend(): any;
    static keep(result: any): any;
    static memory(): any;
    static profile(f: any): any;
    static setBackend(backendName: any, safeMode: any): void;
    static tidy(nameOrFn: any, fn: any): any;
    static time(f: any): any;
    constructor(features: any);
    features: any;
    registry: any;
    evaluateFeature(feature: any): any;
    findBackend(name: any): any;
    get(feature: any): any;
    getBestBackendName(): any;
    getFeatures(): any;
    initEngine(): void;
    registerBackend(name: any, factory: any, priority: any, setTensorTrackerFn: any): any;
    removeBackend(name: any): void;
    reset(): void;
    set(feature: any, value: any): void;
    setFeatures(features: any): void;
  }
  function deprecationWarn(msg: any): void;
  function disableDeprecationWarnings(): void;
  function enableProdMode(): void;
}
export function equal(...args: any[]): any;
export function equalStrict(...args: any[]): any;
export function erf(...args: any[]): any;
export function exp(...args: any[]): any;
export function expandDims(...args: any[]): any;
export function expm1(...args: any[]): any;
export function eye(...args: any[]): any;
export function fft(...args: any[]): any;
export function fill(shape: any, value: any, dtype: any): any;
export function floor(...args: any[]): any;
export function floorDiv(...args: any[]): any;
export function fromPixels(pixels: any, numChannels: any): any;
export namespace fused {
  function matMul(...args: any[]): any;
}
export function gather(...args: any[]): any;
export function gatherND(...args: any[]): any;
export function getBackend(): any;
export function grad(f: any): any;
export function grads(f: any): any;
export function greater(...args: any[]): any;
export function greaterEqual(...args: any[]): any;
export function greaterEqualStrict(...args: any[]): any;
export function greaterStrict(...args: any[]): any;
export function ifft(...args: any[]): any;
export function imag(...args: any[]): any;
export namespace image {
  function cropAndResize(...args: any[]): any;
  function nonMaxSuppression(...args: any[]): any;
  function nonMaxSuppressionAsync(boxes: any, scores: any, maxOutputSize: any, iouThreshold: any, scoreThreshold: any): any;
  function resizeBilinear(...args: any[]): any;
  function resizeNearestNeighbor(...args: any[]): any;
}
export namespace io {
  function browserFiles(files: any): any;
  function browserHTTPRequest(path: any, requestInit: any, weightPathPrefix: any, fetchFunc: any, onProgress: any): any;
  function concatenateArrayBuffers(buffers: any): any;
  function copyModel(sourceURL: any, destURL: any): any;
  function decodeWeights(buffer: any, specs: any): any;
  function encodeWeights(tensors: any): any;
  function fromMemory(modelTopology: any, weightSpecs: any, weightData: any): any;
  function getLoadHandlers(url: any, onProgress: any): any;
  function getModelArtifactsInfoForJSON(modelArtifacts: any): any;
  function getSaveHandlers(url: any): any;
  function isHTTPScheme(url: any): any;
  function listModels(): any;
  function loadWeights(manifest: any, filePathPrefix: any, weightNames: any, requestOptions: any): any;
  function moveModel(sourceURL: any, destURL: any): any;
  function registerLoadRouter(loudRouter: any): any;
  function registerSaveRouter(loudRouter: any): any;
  function removeModel(url: any): any;
  function weightsLoaderFactory(fetchWeightsFunction: any): any;
  function withSaveHandler(saveHandler: any): any;
}
export function irfft(...args: any[]): any;
export function keep(result: any): any;
export function leakyRelu(...args: any[]): any;
export function less(...args: any[]): any;
export function lessEqual(...args: any[]): any;
export function lessEqualStrict(...args: any[]): any;
export function lessStrict(...args: any[]): any;
export namespace linalg {
  function gramSchmidt(...args: any[]): any;
  function qr(...args: any[]): any;
}
export function linspace(start: any, stop: any, num: any): any;
export function localResponseNormalization(...args: any[]): any;
export function log(...args: any[]): any;
export function log1p(...args: any[]): any;
export function logSigmoid(...args: any[]): any;
export function logSoftmax(...args: any[]): any;
export function logSumExp(...args: any[]): any;
export function logicalAnd(...args: any[]): any;
export function logicalNot(...args: any[]): any;
export function logicalOr(...args: any[]): any;
export function logicalXor(...args: any[]): any;
export namespace losses {
  const Reduction: {
    "0": string;
    "1": string;
    "2": string;
    "3": string;
    MEAN: number;
    NONE: number;
    SUM: number;
    SUM_BY_NONZERO_WEIGHTS: number;
  };
  function absoluteDifference(...args: any[]): any;
  function computeWeightedLoss(...args: any[]): any;
  function cosineDistance(...args: any[]): any;
  function hingeLoss(...args: any[]): any;
  function huberLoss(...args: any[]): any;
  function logLoss(...args: any[]): any;
  function meanSquaredError(...args: any[]): any;
  function sigmoidCrossEntropy(...args: any[]): any;
  function softmaxCrossEntropy(...args: any[]): any;
}
export function matMul(...args: any[]): any;
export namespace math {
  function confusionMatrix(...args: any[]): any;
}
export function max(...args: any[]): any;
export function maxPool(...args: any[]): any;
export function maximum(...args: any[]): any;
export function maximumStrict(...args: any[]): any;
export function mean(...args: any[]): any;
export function memory(): any;
export function min(...args: any[]): any;
export function minimum(...args: any[]): any;
export function minimumStrict(...args: any[]): any;
export function mod(...args: any[]): any;
export function modStrict(...args: any[]): any;
export function moments(...args: any[]): any;
export function movingAverage(...args: any[]): any;
export function mul(...args: any[]): any;
export function mulStrict(...args: any[]): any;
export function multiRNNCell(...args: any[]): any;
export function multinomial(...args: any[]): any;
export function neg(...args: any[]): any;
export function nextFrame(): any;
export function norm(...args: any[]): any;
export function notEqual(...args: any[]): any;
export function notEqualStrict(...args: any[]): any;
export function oneHot(...args: any[]): any;
export function ones(shape: any, dtype: any): any;
export function onesLike(...args: any[]): any;
export function op(f: any): any;
export function outerProduct(...args: any[]): any;
export function pad(...args: any[]): any;
export function pad1d(...args: any[]): any;
export function pad2d(...args: any[]): any;
export function pad3d(...args: any[]): any;
export function pad4d(...args: any[]): any;
export function pool(...args: any[]): any;
export function pow(...args: any[]): any;
export function powStrict(...args: any[]): any;
export function prelu(...args: any[]): any;
export function print(x: any, verbose: any): void;
export function prod(...args: any[]): any;
export function profile(f: any): any;
export function rand(...args: any[]): any;
export function randomNormal(...args: any[]): any;
export function randomUniform(...args: any[]): any;
export function range(start: any, stop: any, step: any, dtype: any): any;
export function real(...args: any[]): any;
export function reciprocal(...args: any[]): any;
export function relu(...args: any[]): any;
export function reshape(...args: any[]): any;
export function reverse(...args: any[]): any;
export function reverse1d(...args: any[]): any;
export function reverse2d(...args: any[]): any;
export function reverse3d(...args: any[]): any;
export function reverse4d(...args: any[]): any;
export function rfft(...args: any[]): any;
export function round(...args: any[]): any;
export function rsqrt(...args: any[]): any;
export function scalar(value: any, dtype: any): any;
export function scatterND(...args: any[]): any;
export function selu(...args: any[]): any;
export function separableConv2d(...args: any[]): any;
export namespace serialization {
  class Serializable {
    static fromConfig(cls: any, config: any): any;
    getClassName(): any;
  }
  class SerializationMap {
    static getMap(): any;
    static instance: {
      classNameMap: {
        AdadeltaOptimizer: any;
        AdagradOptimizer: any;
        AdamOptimizer: any;
        AdamaxOptimizer: any;
        MomentumOptimizer: any;
        RMSPropOptimizer: any;
        SGDOptimizer: any;
      };
    };
    static register(cls: any): void;
    classNameMap: any;
  }
  function registerClass(cls: any): void;
}
export function setBackend(backendName: any, safeMode: any): void;
export function setdiff1dAsync(x: any, y: any): any;
export function sigmoid(...args: any[]): any;
export function sign(...args: any[]): any;
export function sin(...args: any[]): any;
export function sinh(...args: any[]): any;
export function slice(...args: any[]): any;
export function slice1d(...args: any[]): any;
export function slice2d(...args: any[]): any;
export function slice3d(...args: any[]): any;
export function slice4d(...args: any[]): any;
export function softmax(...args: any[]): any;
export function softplus(...args: any[]): any;
export function spaceToBatchND(...args: any[]): any;
export function sparseToDense(...args: any[]): any;
export namespace spectral {
  function fft(...args: any[]): any;
  function ifft(...args: any[]): any;
  function irfft(...args: any[]): any;
  function rfft(...args: any[]): any;
}
export function split(...args: any[]): any;
export function sqrt(...args: any[]): any;
export function square(...args: any[]): any;
export function squaredDifference(...args: any[]): any;
export function squaredDifferenceStrict(...args: any[]): any;
export function squeeze(...args: any[]): any;
export function stack(...args: any[]): any;
export function step(...args: any[]): any;
export function stridedSlice(...args: any[]): any;
export function sub(...args: any[]): any;
export function subStrict(...args: any[]): any;
export function sum(...args: any[]): any;
export function tan(...args: any[]): any;
export function tanh(...args: any[]): any;
export function tensor(values: any, shape: any, dtype: any): any;
export function tensor1d(values: any, dtype: any): any;
export function tensor2d(values: any, shape: any, dtype: any): any;
export function tensor3d(values: any, shape: any, dtype: any): any;
export function tensor4d(values: any, shape: any, dtype: any): any;
export function tensor5d(values: any, shape: any, dtype: any): any;
export function tensor6d(values: any, shape: any, dtype: any): any;
export namespace test_util {
  const ALL_ENVS: {};
  const BROWSER_ENVS: {
    IS_BROWSER: boolean;
  };
  const CHROME_ENVS: {
    IS_CHROME: boolean;
  };
  const CPU_ENVS: {
    HAS_WEBGL: boolean;
  };
  const NODE_ENVS: {
    IS_NODE: boolean;
  };
  const PACKED_ENVS: {
    WEBGL_PACK: boolean;
  };
  const WEBGL_ENVS: {
    HAS_WEBGL: boolean;
  };
  function expectArrayBuffersEqual(actual: any, expected: any): void;
  function expectArraysClose(actual: any, expected: any, epsilon: any): any;
  function expectArraysEqual(actual: any, expected: any): any;
  function expectNumbersClose(a: any, e: any, epsilon: any): void;
  function expectPromiseToFail(fn: any, done: any): void;
  function expectValuesInRange(actual: any, low: any, high: any): void;
}
export function tidy(nameOrFn: any, fn: any): any;
export function tile(...args: any[]): any;
export function time(f: any): any;
export function toPixels(img: any, canvas: any): any;
export function topk(...args: any[]): any;
export namespace train {
  function adadelta(learningRate: any, rho: any, epsilon: any): any;
  function adagrad(learningRate: any, initialAccumulatorValue: any): any;
  function adam(learningRate: any, beta1: any, beta2: any, epsilon: any): any;
  function adamax(learningRate: any, beta1: any, beta2: any, epsilon: any, decay: any): any;
  function momentum(learningRate: any, momentum: any, useNesterov: any): any;
  function rmsprop(learningRate: any, decay: any, momentum: any, epsilon: any, centered: any): any;
  function sgd(learningRate: any): any;
}
export function transpose(...args: any[]): any;
export function truncatedNormal(...args: any[]): any;
export function unsortedSegmentSum(...args: any[]): any;
export function unstack(...args: any[]): any;
export namespace util {
  function arraysEqual(n1: any, n2: any): any;
  function assert(expr: any, msg: any): void;
  function assertNonNull(a: any): void;
  function assertShapesMatch(shapeA: any, shapeB: any, errorMessagePrefix: any): void;
  function bytesFromStringArray(arr: any): any;
  function bytesPerElement(dtype: any): any;
  function checkComputationForErrors(vals: any, dtype: any, name: any): void;
  function checkConversionForErrors(vals: any, dtype: any): void;
  function clamp(min: any, x: any, max: any): any;
  function computeStrides(shape: any): any;
  function createShuffledIndices(n: any): any;
  function distSquared(a: any, b: any): any;
  function flatten(arr: any, ret: any): any;
  function getArrayFromDType(dtype: any, size: any): any;
  function getTypedArrayFromDType(dtype: any, size: any): any;
  function hasEncodingLoss(oldType: any, newType: any): any;
  function inferDtype(values: any): any;
  function inferFromImplicitShape(shape: any, size: any): any;
  function isBoolean(value: any): any;
  function isFunction(f: any): any;
  function isInt(a: any): any;
  function isNumber(value: any): any;
  function isScalarShape(shape: any): any;
  function isString(value: any): any;
  function isTypedArray(a: any): any;
  function makeOnesTypedArray(size: any, dtype: any): any;
  function makeZerosTypedArray(size: any, dtype: any): any;
  function monitorPromisesProgress(promises: any, onProgress: any, startFraction: any, endFraction: any): any;
  function nearestDivisor(size: any, start: any): any;
  function nearestLargerEven(val: any): any;
  function now(): any;
  function parseAxisParam(axis: any, shape: any): any;
  function randUniform(a: any, b: any): any;
  function repeatedTry(checkFn: any, delayFn: any, maxCounter: any): any;
  function rightPad(a: any, size: any): any;
  function shuffle(array: any): void;
  function sizeFromShape(shape: any): any;
  function sizeToSquarishShape(size: any): any;
  function squeezeShape(shape: any, axis: any): any;
  function sum(arr: any): any;
  function tanh(x: any): any;
  function toNestedArray(shape: any, a: any): any;
  function toTypedArray(a: any, dtype: any, debugMode: any): any;
}
export function valueAndGrad(f: any): any;
export function valueAndGrads(f: any): any;
export function variable(initialValue: any, trainable: any, name: any, dtype: any): any;
export function variableGrads(f: any, varList: any): any;
export const version_core: string;
export namespace webgl {
  class GPGPUContext {
    constructor(gl: any);
    outputTexture: any;
    program: any;
    disposed: any;
    autoDebugValidate: any;
    vertexAttrsAreBound: any;
    itemsToPoll: any;
    gl: any;
    textureFloatExtension: any;
    colorBufferFloatExtension: any;
    textureHalfFloatExtension: any;
    colorBufferHalfFloatExtension: any;
    vertexBuffer: any;
    indexBuffer: any;
    framebuffer: any;
    textureConfig: any;
    addItemToPoll(isDoneFn: any, resolveFn: any): void;
    beginQuery(): any;
    bindTextureToFrameBuffer(texture: any): void;
    blockUntilAllProgramsCompleted(): void;
    createAndWaitForFence(): any;
    createFence(gl: any): any;
    createFloat16MatrixTexture(rows: any, columns: any): any;
    createFloat16PackedMatrixTexture(rows: any, columns: any): any;
    createFloat32MatrixTexture(rows: any, columns: any): any;
    createPackedMatrixTexture(rows: any, columns: any): any;
    createProgram(fragmentShaderSource: any): any;
    createUnsignedBytesMatrixTexture(rows: any, columns: any): any;
    debugValidate(): void;
    deleteMatrixTexture(texture: any): void;
    deleteProgram(program: any): void;
    dispose(): void;
    downloadByteEncodedFloatMatrixFromOutputTexture(texture: any, rows: any, columns: any): any;
    downloadFloat32MatrixFromBuffer(buffer: any, rows: any, columns: any): any;
    downloadFloat32MatrixFromOutputTexture(texture: any, rows: any, columns: any): any;
    downloadMatrixDriver(texture: any, downloadAndDecode: any): any;
    downloadMatrixFromPackedTexture(texture: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any): any;
    downloadPackedMatrixFromBuffer(buffer: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any): any;
    enableAutomaticDebugValidation(enabled: any): void;
    endQuery(): void;
    executeProgram(): void;
    getAttributeLocation(program: any, attribute: any): any;
    getQueryTime(query: any, queryTimerVersion: any): any;
    getQueryTimerExtension(): any;
    getQueryTimerExtensionWebGL1(): any;
    getQueryTimerExtensionWebGL2(): any;
    getUniformLocation(program: any, uniformName: any, shouldThrow: any): any;
    getUniformLocationNoThrow(program: any, uniformName: any): any;
    isQueryAvailable(query: any, queryTimerVersion: any): any;
    maybeCreateBufferFromTexture(texture: any, rows: any, columns: any): any;
    pollFence(fenceContext: any): any;
    pollItems(): void;
    setInputMatrixTexture(inputMatrixTexture: any, uniformLocation: any, textureUnit: any): void;
    setOutputMatrixTexture(outputMatrixTexture: any, rows: any, columns: any): void;
    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked: any, width: any, height: any): void;
    setOutputMatrixWriteRegion(startRow: any, numRows: any, startColumn: any, numColumns: any): void;
    setOutputMatrixWriteRegionDriver(x: any, y: any, width: any, height: any): void;
    setOutputPackedMatrixTexture(outputPackedMatrixTexture: any, rows: any, columns: any): void;
    setOutputPackedMatrixWriteRegion(startRow: any, numRows: any, startColumn: any, numColumns: any): void;
    setProgram(program: any): void;
    throwIfDisposed(): void;
    throwIfNoProgram(): void;
    unbindTextureToFrameBuffer(): void;
    uploadMatrixToPackedTexture(texture: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any, matrix: any): any;
    uploadMatrixToTexture(texture: any, rows: any, columns: any, matrix: any): any;
    uploadPixelDataToTexture(texture: any, pixels: any): void;
    waitForQueryAndGetTime(query: any): any;
  }
  class MathBackendWebGL {
    constructor(gpgpu: any, delayedStorage: any);
    gpgpu: any;
    delayedStorage: any;
    pendingRead: any;
    pendingDisposal: any;
    dataRefCount: any;
    lruDataGPU: any;
    numBytesInGPU: any;
    uploadWaitMs: any;
    downloadWaitMs: any;
    binaryCache: any;
    disposed: any;
    canvas: any;
    gpgpuCreatedLocally: any;
    textureManager: any;
    LRNGrad(dy: any, inputImage: any, outputImage: any, depthRadius: any, bias: any, alpha: any, beta: any): any;
    abs(x: any): any;
    acos(x: any): any;
    acosh(x: any): any;
    acquireTexture(dataId: any, texShape: any, texType: any, isPacked: any): any;
    add(a: any, b: any): any;
    addN(tensors: any): any;
    all(x: any, axes: any): any;
    any(x: any, axes: any): any;
    argMax(x: any, axis: any): any;
    argMin(x: any, axis: any): any;
    argReduce(x: any, reduceType: any, bestIndicesA: any): any;
    asin(x: any): any;
    asinh(x: any): any;
    atan(x: any): any;
    atan2(a: any, b: any): any;
    atanh(x: any): any;
    avgPool(x: any, convInfo: any): any;
    avgPoolBackprop(dy: any, x: any, convInfo: any): any;
    batchMatMul(a: any, b: any, transposeA: any, transposeB: any): any;
    batchNormalization(x: any, mean: any, variance: any, varianceEpsilon: any, scale: any, offset: any): any;
    batchToSpaceND(x: any, blockShape: any, crops: any): any;
    cast(x: any, dtype: any): any;
    ceil(x: any): any;
    clip(x: any, min: any, max: any): any;
    compileAndRun(program: any, inputs: any, output: any, customSetup: any, pageToCpu: any): any;
    complex(real: any, imag: any): any;
    complexAbs(x: any): any;
    complexSeparableBinaryOp(a: any, b: any, op: any): any;
    computeBytes(shape: any, dtype: any): any;
    concat(tensors: any, axis: any): any;
    conv2d(x: any, filter: any, convInfo: any): any;
    conv2dDerFilter(x: any, dy: any, convInfo: any): any;
    conv2dDerInput(dy: any, filter: any, convInfo: any): any;
    conv2dWithIm2Row(x: any, filter: any, convInfo: any): any;
    conv3d(x: any, filter: any, convInfo: any): any;
    conv3dDerFilter(x: any, dy: any, convInfo: any): any;
    conv3dDerInput(dy: any, filter: any, convInfo: any): any;
    convertAndCacheOnCPU(dataId: any, float32Values: any): any;
    cos(x: any): any;
    cosh(x: any): any;
    cropAndResize(image: any, boxes: any, boxIndex: any, cropSize: any, method: any, extrapolationValue: any): any;
    cumsum(x: any, axis: any, exclusive: any, reverse: any): any;
    depthToSpace(x: any, blockSize: any, dataFormat: any): any;
    depthwiseConv2D(x: any, filter: any, convInfo: any): any;
    depthwiseConv2DDerFilter(x: any, dy: any, convInfo: any): any;
    depthwiseConv2DDerInput(dy: any, filter: any, convInfo: any): any;
    dispose(): void;
    disposeData(dataId: any): void;
    elu(x: any): any;
    eluDer(dy: any, y: any): any;
    endTimer(query: any): any;
    equal(a: any, b: any): any;
    erf(x: any): any;
    exp(x: any): any;
    expm1(x: any): any;
    fft(x: any): any;
    fftImpl(x: any, inverse: any): any;
    floatPrecision(): any;
    floor(x: any): any;
    floorDiv(a: any, b: any): any;
    fromPixels(pixels: any, numChannels: any): any;
    fusedBatchMatMul(a: any, b: any, transposeA: any, transposeB: any, bias: any, activation: any): any;
    gather(x: any, indices: any, axis: any): any;
    gatherND(x: any, indices: any): any;
    getAndSaveBinary(key: any, getBinary: any): any;
    getCPUBackend(): any;
    getCanvas(): any;
    getGPGPUContext(): any;
    getQueryTime(query: any): any;
    getTexture(dataId: any): any;
    getTextureManager(): any;
    getValuesFromTexture(dataId: any): any;
    greater(a: any, b: any): any;
    greaterEqual(a: any, b: any): any;
    ifft(x: any): any;
    imag(input: any): any;
    int(x: any): any;
    less(a: any, b: any): any;
    lessEqual(a: any, b: any): any;
    localResponseNormalization4D(x: any, radius: any, bias: any, alpha: any, beta: any): any;
    log(x: any): any;
    log1p(x: any): any;
    logicalAnd(a: any, b: any): any;
    logicalNot(x: any): any;
    logicalOr(a: any, b: any): any;
    makeComplexComponentTensorHandle(complexTensor: any, complexPart: any): any;
    makeOutputArray(shape: any, dtype: any): any;
    makePackedTensor(shape: any, dtype: any): any;
    makeTensorHandle(shape: any, dtype: any): any;
    max(x: any, axes: any): any;
    maxPool(x: any, convInfo: any): any;
    maxPoolBackprop(dy: any, x: any, y: any, convInfo: any): any;
    maximum(a: any, b: any): any;
    memory(): any;
    min(x: any, axes: any): any;
    minimum(a: any, b: any): any;
    mod(a: any, b: any): any;
    multinomial(logits: any, normalized: any, numSamples: any, seed: any): any;
    multiply(a: any, b: any): any;
    neg(x: any): any;
    nonMaxSuppression(boxes: any, scores: any, maxOutputSize: any, iouThreshold: any, scoreThreshold: any): any;
    notEqual(a: any, b: any): any;
    oneHot(indices: any, depth: any, onValue: any, offValue: any): any;
    packedBinaryOp(a: any, b: any, op: any, dtype: any): any;
    packedReshape(input: any, afterShape: any): any;
    pad(x: any, paddings: any, constantValue: any): any;
    pow(a: any, b: any): any;
    prelu(x: any, alpha: any): any;
    prod(x: any, axes: any): any;
    read(dataId: any): any;
    readSync(dataId: any): any;
    real(input: any): any;
    realDivide(a: any, b: any): any;
    reciprocal(x: any): any;
    reduce(x: any, reduceType: any, dtype: any): any;
    register(dataId: any, shape: any, dtype: any): void;
    releaseTexture(dataId: any, texture: any, texShape: any, texType: any, isPacked: any): void;
    relu(x: any): any;
    reshape(x: any, shape: any): any;
    resizeBilinear(x: any, newHeight: any, newWidth: any, alignCorners: any): any;
    resizeBilinearBackprop(dy: any, x: any, alignCorners: any): any;
    resizeNearestNeighbor(x: any, newHeight: any, newWidth: any, alignCorners: any): any;
    resizeNearestNeighborBackprop(dy: any, x: any, alignCorners: any): any;
    reverse(x: any, axis: any): any;
    round(x: any): any;
    rsqrt(x: any): any;
    scatterND(indices: any, updates: any, shape: any): any;
    segOpCompute(x: any, segOpType: any, segmentIds: any, dtype: any, numSegments: any): any;
    select(condition: any, a: any, b: any): any;
    selu(x: any): any;
    setDataMover(dataMover: any): void;
    shallowSlice(x: any, begin: any, size: any): any;
    shouldExecuteOnCPU(inputs: any, sizeThreshold: any): any;
    sigmoid(x: any): any;
    sign(x: any): any;
    sin(x: any): any;
    sinh(x: any): any;
    slice(x: any, begin: any, size: any): any;
    softplus(x: any): any;
    spaceToBatchND(x: any, blockShape: any, paddings: any): any;
    sparseToDense(sparseIndices: any, sparseValues: any, outputShape: any, defaultValue: any): any;
    split(x: any, sizeSplits: any, axis: any): any;
    sqrt(x: any): any;
    square(x: any): any;
    squaredDifference(a: any, b: any): any;
    startTimer(): any;
    step(x: any, alpha: any): any;
    stridedSlice(x: any, begin: any, end: any, strides: any, beginMask: any, endMask: any, ellipsisMask: any, newAxisMask: any, shrinkAxisMask: any): any;
    subtract(a: any, b: any): any;
    sum(x: any, axes: any): any;
    tan(x: any): any;
    tanh(x: any): any;
    tile(x: any, reps: any): any;
    time(f: any): any;
    topk(x: any, k: any, sorted: any): any;
    transpose(x: any, perm: any): any;
    unpackTensor(input: any): any;
    unsortedSegmentSum(x: any, segmentIds: any, numSegments: any): any;
    unstack(x: any, axis: any): any;
    uploadToGPU(dataId: any): void;
    where(condition: any): any;
    write(dataId: any, values: any): void;
  }
  namespace gpgpu_util {
    function bindVertexProgramAttributeStreams(gl: any, program: any, vertexBuffer: any): any;
    function createFloat16MatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function createFloat16PackedMatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function createFloat32MatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function createIndexBuffer(gl: any): any;
    function createPackedMatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function createUnsignedBytesMatrixTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function createVertexBuffer(gl: any): any;
    function createVertexShader(gl: any): any;
    function downloadByteEncodedFloatMatrixFromOutputTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function downloadFloat32MatrixFromBuffer(gl: any, buffer: any, rows: any, columns: any, textureConfig: any): any;
    function downloadFloat32MatrixFromOutputTexture(gl: any, rows: any, columns: any, textureConfig: any): any;
    function downloadMatrixFromPackedOutputTexture(gl: any, batch: any, rows: any, cols: any, physicalRows: any, physicalCols: any, textureConfig: any): any;
    function downloadPackedMatrixFromBuffer(gl: any, buffer: any, batch: any, rows: any, cols: any, physicalRows: any, physicalCols: any, textureConfig: any): any;
    function getTextureConfig(gl: any, textureHalfFloatExtension: any): any;
    function maybeCreateBufferFromOutputTexture(gl: any, texture: any, rows: any, columns: any, textureConfig: any): any;
    function uploadMatrixToPackedTexture(gl: any, texture: any, batch: any, rows: any, columns: any, physicalRows: any, physicalCols: any, matrix: any, textureConfig: any): void;
    function uploadMatrixToTexture(gl: any, texture: any, rows: any, columns: any, matrix: any, numChannels: any, textureConfig: any): void;
    function uploadPixelDataToTexture(gl: any, texture: any, pixels: any): void;
  }
  namespace webgl_util {
    function bindCanvasToFramebuffer(gl: any): void;
    function bindColorTextureToFramebuffer(gl: any, texture: any, framebuffer: any): void;
    function bindTextureToProgramUniformSampler(gl: any, program: any, texture: any, uniformSamplerLocation: any, textureUnit: any): void;
    function bindTextureUnit(gl: any, texture: any, textureUnit: any): void;
    function bindVertexBufferToProgramAttribute(gl: any, program: any, attribute: any, buffer: any, arrayEntriesPerItem: any, itemStrideInBytes: any, itemOffsetInBytes: any): any;
    function callAndCheck(gl: any, func: any): any;
    function canBeRepresented(num: any): any;
    function checkWebGLError(gl: any): void;
    function createFragmentShader(gl: any, fragmentShaderSource: any): any;
    function createFramebuffer(gl: any): any;
    function createProgram(gl: any): any;
    function createStaticIndexBuffer(gl: any, data: any): any;
    function createStaticVertexBuffer(gl: any, data: any): any;
    function createTexture(gl: any): any;
    function createVertexShader(gl: any, vertexShaderSource: any): any;
    function enableDebugWebGLErrorChecking(enabled: any): void;
    function getBatchDim(shape: any, dimsToSkip: any): any;
    function getExtensionOrThrow(gl: any, extensionName: any): any;
    function getFramebufferErrorMessage(gl: any, status: any): any;
    function getNumChannels(): any;
    function getProgramUniformLocation(gl: any, program: any, uniformName: any): any;
    function getProgramUniformLocationOrThrow(gl: any, program: any, uniformName: any): any;
    function getRowsCols(shape: any): any;
    function getTextureShapeFromLogicalShape(logShape: any, isPacked: any): any;
    function getWebGLErrorMessage(gl: any, status: any): any;
    function isReshapeFree(shape1: any, shape2: any): any;
    function linkProgram(gl: any, program: any): void;
    function unbindColorTextureFromFramebuffer(gl: any, framebuffer: any): void;
    function unbindTextureUnit(gl: any, textureUnit: any): void;
    function validateFramebuffer(gl: any): void;
    function validateProgram(gl: any, program: any): void;
    function validateTextureSize(width: any, height: any): void;
  }
}
export function where(...args: any[]): any;
export function whereAsync(condition: any): any;
export function zeros(shape: any, dtype: any): any;
export function zerosLike(...args: any[]): any;
